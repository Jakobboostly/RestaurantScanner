async getLocalCompetitiveKeywords(
  businessName: string,
  cuisine: string,
  city: string,
  state: string,
  locationName: string = 'United States',
  languageCode: string = 'en'
): Promise<ProcessedKeyword[]> {

  // Generate the 8 local keyword patterns
  const localKeywordPatterns = [
    `${cuisine} near me`,
    `${cuisine} delivery ${city}`,
    `best ${cuisine} ${city}`,
    `${city} ${cuisine}`,
    `${cuisine} places near me`,
    `${cuisine} ${city} ${state}`,
    `${cuisine} delivery near me`,
    `${cuisine} open now`
  ];

  const results: ProcessedKeyword[] = [];
  const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

  // Use Local Finder API for each keyword
  for (const keyword of localKeywordPatterns) {
    try {
      console.log(`üîç Checking local rankings for: "${keyword}"`);
      
      // Add delay to avoid rate limiting
      await delay(1000);
      
      // Use Local Finder API instead of regular SERP
      const response = await this.client.post('/serp/google/local_finder/live/advanced', [{
        keyword: keyword,
        location_name: locationName,
        language_code: languageCode,
        depth: 50, // Check up to 50 local businesses
        device: 'desktop',
        min_rating: 3.5 // Only businesses with decent ratings
      }]);

      const result = response.data.tasks?.[0]?.result?.[0];
      const localBusinesses = result?.items || [];
      
      console.log(`    üìä Found ${localBusinesses.length} local businesses`);
      
      // Find where your business ranks in local pack
      let position = 0;
      let foundBusiness = null;
      
      for (let i = 0; i < localBusinesses.length; i++) {
        const business = localBusinesses[i];
        
        // Match by business name (more flexible matching)
        const businessTitle = business.title?.toLowerCase() || '';
        const targetName = businessName.toLowerCase();
        
        if (businessTitle.includes(targetName) || 
            targetName.includes(businessTitle.split(' ')[0]) || // Match first word
            business.domain?.includes(targetName.replace(/\s+/g, ''))) { // Match domain
          
          position = business.rank_absolute || (i + 1);
          foundBusiness = business;
          break;
        }
      }

      // Only include if ranking in positions 6+ (competitors beating you)
      if (position > 5) {
        // Get search volume data separately
        const volumeResponse = await this.client.post('/dataforseo_labs/google/keyword_overview/live', [{
          keywords: [keyword],
          location_name: locationName,
          language_code: languageCode
        }]);
        
        const volumeData = volumeResponse.data.tasks[0].result[0].items[0];
        
        results.push({
          keyword: keyword,
          position: position,
          searchVolume: volumeData?.keyword_info?.search_volume || 0,
          difficulty: volumeData?.keyword_info?.keyword_difficulty || 0,
          cpc: volumeData?.keyword_info?.cpc || 0,
          competition: volumeData?.keyword_info?.competition || 0,
          
          // Local-specific data from Local Finder
          localData: {
            rating: foundBusiness?.rating?.value || 0,
            reviewCount: foundBusiness?.rating?.votes_count || 0,
            phone: foundBusiness?.phone || '',
            address: foundBusiness?.description?.split('\n')[1] || '',
            businessUrl: foundBusiness?.url || '',
            domain: foundBusiness?.domain || ''
          },
          
          // Top 5 competitors (who are beating you)
          topCompetitors: localBusinesses.slice(0, Math.min(5, position - 1)).map(comp => ({
            name: comp.title,
            position: comp.rank_absolute,
            rating: comp.rating?.value || 0,
            reviewCount: comp.rating?.votes_count || 0,
            domain: comp.domain || 'No website'
          })),
          
          opportunityScore: this.calculateLocalOpportunityScore(
            position, 
            volumeData?.keyword_info?.search_volume || 0,
            foundBusiness?.rating?.value || 0
          )
        });
        
        console.log(`    ‚úÖ Found at position ${position} for "${keyword}"`);
      } else if (position > 0) {
        console.log(`    üéØ Already in top 5 (position ${position}) for "${keyword}"`);
      } else {
        console.log(`    ‚ùå Not found in local results for "${keyword}"`);
      }

    } catch (error) {
      console.error(`    ‚ùå Error checking "${keyword}":`, error.message);
    }
  }

  // Sort by opportunity score and return top results
  return results
    .sort((a, b) => b.opportunityScore - a.opportunityScore)
    .slice(0, 8);
}

private calculateLocalOpportunityScore(
  position: number, 
  searchVolume: number, 
  currentRating: number
): number {
  // Local opportunity scoring factors:
  const positionScore = Math.max(0, 25 - position); // Closer to top = higher score
  const volumeScore = Math.log10(searchVolume + 1) * 5; // Higher volume = higher score
  const ratingScore = currentRating * 2; // Better rating = easier to improve
  
  return positionScore + volumeScore + ratingScore;
}

// Alternative: Check if business appears in ANY position for these keywords
async getLocalVisibilityReport(
  businessName: string,
  cuisine: string,
  city: string,
  state: string,
  locationName: string = 'United States'
): Promise<{
  visibleKeywords: ProcessedKeyword[],
  invisibleKeywords: string[],
  totalOpportunities: number
}> {
  
  const keywordPatterns = [
    `${cuisine} near me`,
    `${cuisine} delivery ${city}`,
    `best ${cuisine} ${city}`,
    `${city} ${cuisine}`,
    `${cuisine} places near me`,
    `${cuisine} ${city} ${state}`,
    `${cuisine} delivery near me`,
    `${cuisine} open now`
  ];

  const visibleKeywords: ProcessedKeyword[] = [];
  const invisibleKeywords: string[] = [];

  for (const keyword of keywordPatterns) {
    const rankings = await this.getLocalCompetitiveKeywords(
      businessName, cuisine, city, state, locationName
    );
    
    const found = rankings.find(r => r.keyword === keyword);
    if (found) {
      visibleKeywords.push(found);
    } else {
      invisibleKeywords.push(keyword);
    }
  }

  return {
    visibleKeywords,
    invisibleKeywords,
    totalOpportunities: visibleKeywords.filter(k => k.position > 5).length
  };
}